#include <iostream>
#include <string>
#include <vector>
#include <math.h> 

class Config {      
  public:   
   // Print the process or not
      bool verbose = true;

      // Name of base network
      std::string network = "vgg";

      // Setting for data augmentation
      bool use_horizontal_flips = false;
      bool use_vertical_flips = false;
      bool rot_90 = false;

      // Anchor box scales
      // Note that if im_size is smaller, anchor_box_scales should be scaled
      // Original anchor_box_scales in the paper is [128, 256, 512]
      std::vector<int> anchor_box_scales{64, 128, 256};

      // Anchor box ratios
      std::vector<std::vector<double>> anchor_box_ratios{{1.0, 1.0}, {1.0 / sqrt(2), 2.0 / sqrt(2)}, {2.0 / sqrt(2), 1 / sqrt(2)}};

      // Size to resize the smallest side of the image
      // Original setting in paper is 600. Set to 300 in here to save training time
      int im_size = 300;

      // image channel-wise mean to subtract
      std::vector<double> img_channel_mean{103.939, 116.779, 123.68};
      double img_scaling_factor = 1.0;

      // number of ROIs at once
      int num_rois = 4;

      // stride at the RPN (this depends on the network configuration)
      int rpn_stride = 16;

      bool balanced_classes = false;

      // scaling the stdev
      double std_scaling = 4.0;
      std::vector<double> classifier_regr_std{8.0, 8.0, 4.0, 4.0};

      // overlaps for RPN
      double rpn_min_overlap = 0.3;
      double rpn_max_overlap = 0.7;

      // overlaps for classifier ROIs
      double classifier_min_overlap = 0.1;
      double classifier_max_overlap = 0.5;

      // placeholder for the class mapping, automatically generated by the parser
      void *class_mapping;
      std::string model_path;
	
};